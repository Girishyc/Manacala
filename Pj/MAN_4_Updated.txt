(defvar *game* nil )
(defstruct player 
  board-status
  player1-score
  player2-score
  turn
)

(defun initialize-game (n)
  (setf *game* (make-player 
                :board-status (make-array 12 :initial-element n) 
                :player1-score 0
                :player2-score 0
                :turn 1)
                )        
  )
  
 (defun print-board (game) 
   (let ((board-status (player-board-status game))
               (player1-score (player-player1-score game))
               (player2-score (player-player2-score game))
             )
               (terpri)
               
               (princ "----------***MANCALA GAME***----------")
               
               (terpri)
               (princ "_______________________________________")
               (terpri)        
                  (terpri)                                 
               
               (princ "PLAYER1: " )
                        
                         (dotimes (j (/ (length board-status) 2))
                     (princ (aref  board-status j))
                     (princ " | ")
                  )
                    
                    (terpri)
                    (terpri)
          
                (princ " P1-SCORE :") (princ player1-score) 
               (princ "   ")
               (princ " P2-SCORE :")(princ  player2-score)
                    (terpri)
                   (terpri)          
                     
                      (princ "PLAYER2: " )
                          
                        (loop for k from (- (length board-status) 1) downto (/ (length board-status) 2)
                           do
                     (princ (aref  board-status k))
                     (princ " | ")
                 )

                    (terpri)
                    (princ "_______________________________________")
                    (terpri)
                    ))
                    
(defun start-game ()
   (terpri)
   (princ "Enter Pits Element Count :") 
   (setq count (read))
   (initialize-game count)
   (print-board *game*)
)
   
(defun win-status (game)
  (let  ((player1-score (player-player1-score game))
               (player2-score (player-player2-score game))
             )
          (cond (( eq player1-score player2-score)(prog (terpri) (princ "MATCH DRAW")))
                     (( < player1-score player2-score) (prog (terpri) (princ "PLAYER 2 WINS THE GAME")))
          (( > player1-score player2-score) (prog (terpri) (princ "PLAYER 1 WINS THE GAME"))) 
    )
  )
)
  
  (defun game-over-check (game)
    (let ((board-status (player-board-status game))
          (goflag1 t)
          (goflag2 t))
          
                (dotimes (j (/ (length board-status) 2))
                         (if  (not (= 0 (aref board-status j))) (setq goflag1 nil)))
         
                (loop for k from (- (length board-status) 1) downto (/ (length board-status) 2)
                         do
                         (if  (not (= 0 (aref board-status k))) (setq goflag2 nil)))
         
                 (if ( or  goflag1 goflag2 )
                  T)
                 
    )
  ) 
  
(defun decf-board(board-status position)
  (setf (aref board-status position) (+ (aref board-status position) 1)))


(defun player-move(game pit-position)
  (let((board-status (player-board-status game))
       (position pit-position)
       (p 12))
    (setf move-count (aref board-status pit-position))
    (setf (aref board-status pit-position) 0)
    (dotimes (j move-count)
      (if (>= (- pit-position 1) 0)
          (decf-board board-status (decf pit-position))
        (progn(setf pit-position 11)
        (decf-board board-status pit-position))))
        (capture-stones game pit-position)
      ))
    
    
    (defun player-terms (game)
      (let ((pit-position 0))
      (terpri)
      
      (if(eq (player-turn game) 1)
      
      (progn (princ "Player 1 Enter Your Move: ") 
      (setq pit-position (- (read) 1))
      (player-move game pit-position) (setf (player-turn game) 2) (print-board game ))
      
      (progn (princ "Player 2 Enter Your Move: ") 
      (setq pit-position (+ (read) 5))
      (player-move game pit-position) (setf (player-turn game) 1) (print-board game )))))
      
      
         
    
    (defun do-game (game)
			
			(loop do 
             (if (game-over-check game)
            	   (progn (win-status game)(return T))
                   (player-terms game)
                 )))    

  (defun capture-stones(game end-position)
    (let((turn (player-turn game))
         (board-status (player-board-status game))
         (player1-score (player-player1-score game))
         (player2-score (player-player2-score game)))
      (if (eq turn 1)
          (if (and (>= end-position (/ (length board-status) 2)) (<= end-position (- (length board-status) 1)))
              (if (and (<= (aref board-status end-position) 3) (> (aref board-status end-position) 1) )
                  (progn (setf (player-player1-score game) (+ (aref board-status end-position) player1-score))
                    (setf (aref board-status end-position) 0)(capture-stones game (+ end-position 1)))
                )
            )
        (if (and (>= end-position 0) (<= end-position (- (/ (length board-status) 2) 1)))
              (if (and (<= (aref board-status end-position) 3) (> (aref board-status end-position) 1) )
                  (progn (setf (player-player2-score game) (+ (aref board-status end-position) player2-score))
                    (setf (aref board-status end-position) 0) (capture-stones game (+ end-position 1)))
                )
          )
        )))
        
        
      
