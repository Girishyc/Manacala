(defvar *game* nil )
(defvar term 1)
(defstruct player 
		   board-status
           player1
           player2
)

(defstruct player1
           score
)

(defstruct player2
           score
)


(defun initialize-game (n)
  (setf *game* (make-player 
                :board-status (make-array 12 :initial-element n) 
                :player1 (make-player1 :score 0)
                :player2 (make-player2 :score 0)
                )	
  )
)
  
 (defun print-board (game) 
   (let ((board-status (player-board-status game))
 	      (player1-score (player1-score  (player-player1  game)))
 	      (player2-score (player2-score  (player-player2  game)))
 	    )
 	      (terpri)
 	      
 	      (princ "----------***MANCALA GAME***----------")
 	      
 	      (terpri)
 	      (princ "_______________________________________")
 	      (terpri)	
		  (terpri)	 		        
 	      
 	      (princ "PLAYER1: " )
 	       	
 	       	 (dotimes (j (/ (length board-status) 2))
 	            (princ (aref  board-status j))
 	            (princ " | ")
 	         )
 	 	  
 	 	  (terpri)
 	 	  (terpri)
 	 
  	      (princ " P1-SCORE :") (princ player1-score) 
 	      (princ "   ")
 	      (princ " P2-SCORE :")(princ  player2-score)
 	 	  (terpri)
	 	  (terpri) 	 
 	   	 
 	   	  (princ "PLAYER2: " )
 	 		
			(loop for k from (- (length board-status) 1) downto (/ (length board-status) 2)
			   do
 	            (princ (aref  board-status k))
 	            (princ " | ")
 	        )

 	           (terpri)
 	           (princ "_______________________________________")
 	           (terpri)
 	           ))
 	           
(defun start-game (n)
   (initialize-game n)
   (print-board *game*)
)
   
(defun win-status (game)
  (let  ((player1-score (player1-score  (player-player1  game)))
 	      (player2-score (player2-score  (player-player2  game)))
 	    )
  	(cond (( eq player1-score player2-score)(prog (terpri) (princ "MATCH DRAW")))
   		  (( < player1-score player2-score) (prog (terpri) (princ "PLAYER 2 WINS THE GAME")))
          (( > player1-score player2-score) (prog (terpri) (princ "PLAYER 1 WINS THE GAME"))) 
    )
  )
)
  
  (defun game-over-check (game)
    (let ((board-status (player-board-status game))
          (goflag1 t)
          (goflag2 t))
          
        	(dotimes (j (/ (length board-status) 2))
         		(if  (not (= 0 (aref board-status j))) (setq goflag1 nil)))
         
        	(loop for k from (- (length board-status) 1) downto (/ (length board-status) 2)
         		do
        		 (if  (not (= 0 (aref board-status k))) (setq goflag2 nil)))
         
        	 (if ( and  goflag1 goflag2 )
         	(return T))
         	
    )
  ) 
  
 (defun decf-board(board-status position)
  (setf (aref board-status position) (+ (aref board-status position) 1)))


(defun player-move(game pit-position)
  (let((board-status (player-board-status game))
       (position pit-position)
       (p 12))
     (dotimes (j (aref board-status position))
      (if (>= (- position 1) 0)
          (decf-board board-status (decf position))
        (decf-board board-status (decf p))))
    (setf (aref board-status pit-position) 0))) 
    
    
    (defun player-terms (game)
      (let ((pit-position 0))
      (terpri)
      
      if(eq term 1)
      
      (prog (princ "Player 1 Enter Your Move: ") 
      (setq pit-position (read))
      (player-move game pit-position) (setq term1 2))
      
      (prog (princ "Player 2 Enter Your Move: ") 
      (setq pit-position (read))
      (player-move game pit-position))))
      
      
         
    
    (defun do-game (game)
    	(do (num-actions 0 (+ 1 num-actions))
    	   ((not (game-over-check game)) 
    	   (win-status game)) 
    	   (player-terms game)
    	    ))
